#' A microsimulation function to compute expected values
#'
#' Computes the expected values from a Microsimulation transition array 
#' @param trans A transition array generated by `CalculateMicroTrace` function
#' @param rwd List of matrices with state rewards (diagonal) and transition rewards
#         (off-diagonal)
#' @param r Discount factor in the scale of a cycle [0, 1]; default = 0
#' @param half If TRUE apply Half cycle correction. Defaults to TRUE
#' @keywords Microsimulation
#' @return exp.value Expected mean value for the different types of rewards in the list
#' ExpectedValueMicro()

ExpectedValueMicro <- function(trans, rwd, r = 0, half = TRUE) {

  # Number of cycles
  n.Cycles <- dim(trans)[3]   # n.Cycles is equal to dimension 3 of the trans array 
  # Number of states
  n.States <- dim(trans)[1]   # n.States is equal to dimension 1 of the trans array 
  # Calculate the discount vector
  disc <- 1 / (1 + r) ^ seq(0, (n.Cycles - 1))
  # Apply half cycle correction
  if (half) {
    trans[, , 1]        <- trans[, , 1] * 0.5
    trans[, , n.Cycles] <- trans[, , n.Cycles] * 0.5
  }
  
  n.Lists <-  length(rwd)  # number of different rewards in the list 
  
  # Create a matrices to store the output data
  exp_value <- matrix(0, nrow = 1, ncol = n.Lists) 
  trans_rwd <- array(0, dim = c(n.States, n.States, n.Cycles, n.Lists)) 
  trace_rwd <- array(0, dim = c(n.Cycles, n.States, n.Lists))
  
  # Start calculating the rewards for each of type of reward in the list
  for (l in 1:n.Lists) {
    trans_rwd[, , , l] <- array(apply(trans, 3, function(x) x * rwd[[l]]), 
                                dim = c(n.States, n.States, n.Cycles))
    
    trace_rwd[, , l] <- t(colSums(trans_rwd[, , , l])) * disc   # Apply discounting 
    
    exp_value[, l]      <- sum(sum(trace_rwd[, , l]))   # Sum all the values in the matrix
    colnames(exp_value) <- names(rwd)   # Give names to the rewards 
  }
  return(exp_value)   # mean value per reward type 
}
