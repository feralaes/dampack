#' ExpectedValueMicroTimeDepReward
#'
#' This function computes the expected value per individuals from a Microsimulation transition array. While running the function treatment utility decreases with increasing years of being sick. Note: only usefull for the Sick-Sicker model.
#' @param trans A transition array generated by the `CalculateMicroTrace` function
#' @param cum A matrix with the cummulative time being sick or sicker
#' @param rwd List of matrices with state rewards (diagonal) and transition rewards (off-diagonal)
#' @param r Discount factor; default = 0.
#' @param half If TRUE apply half cycle correction
#' @keywords Microsimulation costs outcomes rewards qaly
#' @return exp_value_ind Expected value per individual for the different rewards in the list
#' @return mean Mean expected value for the different rewards in the list
#' ExpectedValueMicroTimeDepReward()
#'

ExpectedValueMicroTimeDepReward <- function(trans, cum,  rwd, r = 0, half = TRUE) {

  # Number of cycles
  n.t <- dim(trans)[3]   # n.t is equal to dimension 3 of the trans array
  # Number of states
  n.s <- dim(trans)[1]   # n.s is equal to dimension 1 of the trans array
  # Number of individuals
  n.i <- dim(trans)[4]   # n.i is equal to dimension 1 of the trans array
  # Number of lists
  n.Lists <- length(rwd)
  # Discount vector
  disc <- DiscountFactor(r)

  # Create matrices to store the data
  exp_value_ind <- matrix(0, nrow = n.i, ncol = n.Lists)
  colnames(exp_value_ind) <- names(rwd)
  trans_rwd     <- array(0, dim = c(n.s, n.s, n.i, n.Lists))
  trans_rwd2    <- array(0, dim = c(n.s, n.s, n.t, n.i))
  trans_rwd3    <- array(0, dim = c(n.s, n.s, n.i))

  # Apply half cycle correction
  if (half == TRUE) {
    trans[, , 1, ]   <- trans[, , 1, ] * 0.5
    trans[, , n.t, ] <- trans[, , n.t, ] * 0.5
  }

  # Discounting the values
  # First create an array to store the discounted values
  trans_disc <- array (0, dim = c(n.s, n.s, n.t, n.i),
    dimnames = list(states, states, cycles, ind))

  # Apply the discounting via multiplication
  trans_disc <- trans * disc

  # Create an array without the cycle dimension
  # This is the reward transition array of each individuals for the complete simulation
  trans_disc2 <- array (0, dim = c(n.s, n.s, n.i),
    dimnames = list(states,  states, ind))

  # Sum the trans_disc array over the n.t
  for (i in 1:n.i) {
    for (s in 1:n.s) {
      for (r in 1:n.s) {
        trans_disc2[s, r, i] <- sum(trans_disc[s, r, , i])
      }
    }
    # multiply the individuals transitions with the different types of rewards
    for (l in 1:n.Lists){
      # Multiply the individual specific discounted transition array with the reward values
      trans_rwd[, , , l]  <- trans_disc2[, , i] * rwd[[l]]
      # Sum all the rewards gained during the simulation
      exp_value_ind[i, l] <-  sum(sum(trans_rwd[, , i, l]))  # Sum all rows and columns together
    }
    for (t in 1:n.t){
      m.h <- matrix (c(0, 0.03 * cum[i, t], 0.03 * cum[i, t], 0,
        0, 0.03 * cum[i, t], 0.03 * cum[i, t], 0,
        0, 0.03 * cum[i, t], 0.03 * cum[i, t], 0,
        0, 0.03 * cum[i, t], 0.03 * cum[i, t], 0),
        nrow = n.s, ncol = n.s, byrow = TRUE)

      trans_rwd2[, , t , i] <- (trans_disc[ , , t, i] * (rwd[[4]] - m.h))
    }

    for (s in 1:n.s){
      for (r in 1:n.s){
        trans_rwd3[s, r, i] <-  sum(trans_rwd2[s, r,  , i])
      }
    }
    exp_value_ind[i, 4] <- sum(sum(trans_rwd3[, , i]))
  }
  mean <- colMeans(exp_value_ind)
  # Return the different rewards in a list
  results <- list(ind = exp_value_ind, mean = mean)
  return(results)
}
